/// generated by chatGPT
use clap::{Parser,Command};
use clap_complete::{generate, Generator, Shell};
use std::io;
#[derive(Parser)]
#[clap(version = "1.0", author = "chatGPT")]
struct MyCLI {
    /// sub command
    #[clap(subcommand)]
    subcmd: SubCommand,
}

#[derive(Parser)]
enum SubCommand {
    /// sub command 1
    Sub1(SubCommand1),
    /// sub command 2, generating completion file
    Sub2(SubCommand2),
}

#[derive(Parser)]
struct SubCommand1 {
    /// sub command 1
    #[clap(subcommand)]
    subcmd: Option<SubSubCommand1>,
}

#[derive(Parser)]
enum SubSubCommand1 {
    /// this is subsub 1
    Subsub1(SubSub1),
    /// this is subsub 2
    Subsub2(SubSub2),
}

#[derive(Parser)]
struct SubSub1 {
    /// a number
    #[clap(short, long)]
    num: i32,
}

#[derive(Parser)]
struct SubSub2 {
    /// path of a file
    #[clap(short, long)]
    file: String,
}

#[derive(Parser)]
struct SubCommand2 {
    /// log level, debug/info/error
    #[clap(long)]
    log_level: Option<String>,
}

fn main() {
    let cli = MyCLI::parse();
    match cli.subcmd {
        SubCommand::Sub1(sub1) => match sub1.subcmd {
            Some(sub_cmd) => match sub_cmd {
                SubSubCommand1::Subsub1(subsub1) => {
                    println!("Running SubSub1 command with num={}", subsub1.num);
                }
                SubSubCommand1::Subsub2(subsub2) => {
                    println!("Running SubSub2 command with file={}", subsub2.file);
                }
            },
            None => {
                println!("Running SubCommand1");
            }
        },

        SubCommand::Sub2(sub2) => {
            println!("Running SubCommand2 with log level {:?}", sub2.log_level);
        }
    }
}
